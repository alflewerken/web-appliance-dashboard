===== CHANGES LOG =====

[2025-01-27 - Webpack Performance Warnings deaktiviert]
Zweck: Verhinderung der Webpack-Performance-Warnings beim Build-Prozess
Datei: frontend/webpack.config.js

--- a/frontend/webpack.config.js
+++ b/frontend/webpack.config.js
@@ -80,5 +80,10 @@ module.exports = {
       "Access-Control-Allow-Origin": "*",
       "Access-Control-Allow-Methods": "GET, POST, PUT, DELETE, PATCH, OPTIONS",
       "Access-Control-Allow-Headers": "X-Requested-With, content-type, Authorization"
     }
-  }
+  },
+  performance: {
+    hints: false,
+    maxEntrypointSize: 512000,
+    maxAssetSize: 512000
+  }
 };

Beschreibung: 
- Added performance configuration to webpack.config.js
- Set hints: false to disable performance warnings
- Set maxEntrypointSize and maxAssetSize to 512KB (500 KiB)
- This prevents the warnings about bundle size exceeding 244 KiB limit

=======================================
[2025-01-27 - GUACAMOLE_PROXY_URL Warning behoben]
Zweck: Docker Compose Warning bez√ºglich fehlender GUACAMOLE_PROXY_URL Variable beheben
Dateien: .env.example, .env

--- a/.env.example
+++ b/.env.example
@@ -70,6 +70,7 @@ GUACAMOLE_DB_USER=guacamole_user
 GUACAMOLE_DB_PASSWORD=guacamole_pass123
 GUACAMOLE_PORT=9070
 GUACAMOLE_URL=http://localhost:9070/guacamole
+GUACAMOLE_PROXY_URL=
 GUACD_LOG_LEVEL=info
 
 # Logging

--- a/.env
+++ b/.env
@@ -70,6 +70,7 @@ GUACAMOLE_DB_USER=guacamole_user
 GUACAMOLE_DB_PASSWORD=guacamole_pass123
 GUACAMOLE_PORT=9070
 GUACAMOLE_URL=http://localhost:9070/guacamole
+GUACAMOLE_PROXY_URL=
 GUACD_LOG_LEVEL=info
 
 # Logging

Beschreibung:
- Added GUACAMOLE_PROXY_URL variable to .env.example and .env files
- Set to empty string by default (blank value)
- This prevents the Docker Compose warning about missing variable
- Variable is used in docker-compose.yml for backend service environment

=======================================[2025-01-27 - ProxyService Migration]
Zweck: ProxyService von api/ nach services/ Verzeichnis verschoben
Dateien: frontend/src/api/proxyService.js -> frontend/src/services/proxyService.js

Durchgef√ºhrte Aktionen:
1. Alte proxyService.js in services/ zu proxyService.old.js umbenannt (Backup)
2. Neue proxyService.js von api/ nach services/ verschoben
3. Leeres api/ Verzeichnis gel√∂scht

--- Dateistruktur vorher:
frontend/src/
‚îú‚îÄ‚îÄ api/
‚îÇ   ‚îî‚îÄ‚îÄ proxyService.js (neue Version)
‚îî‚îÄ‚îÄ services/
    ‚îî‚îÄ‚îÄ proxyService.js (alte Version)

+++ Dateistruktur nachher:
frontend/src/
‚îî‚îÄ‚îÄ services/
    ‚îú‚îÄ‚îÄ proxyService.js (neue Version)
    ‚îî‚îÄ‚îÄ proxyService.old.js (alte Version als Backup)

Beschreibung:
- Die neue proxyService.js aus dem api/ Verzeichnis bietet erweiterte Funktionalit√§t
- Alle bestehenden Imports zeigen bereits auf services/proxyService
- Die alte Version wurde als Backup gespeichert f√ºr den Fall von Kompatibilit√§tsproblemen
- Das api/ Verzeichnis wurde entfernt, da es nun leer war

WICHTIG: Die neue proxyService.js hat eine andere API-Struktur:
- Alt: getProxyUrl(applianceId, path) f√ºr Appliances
- Neu: getProxyUrl(serviceId, path) f√ºr Services
- M√∂glicherweise m√ºssen die importierenden Komponenten angepasst werden

=======================================[2025-01-27 - ProxyService Migration ROLLBACK]
Zweck: R√ºckg√§ngigmachung der ProxyService Migration wegen Inkompatibilit√§t
Dateien: services/proxyService.js

Durchgef√ºhrte Aktionen:
1. Neue Version zu proxyService.new.js umbenannt (f√ºr sp√§tere Analyse)
2. Alte Version von proxyService.old.js zur√ºck zu proxyService.js

Grund f√ºr Rollback:
- Die neue proxyService.js hat eine andere API-Struktur
- Bestehende Komponenten nutzen Methoden wie openInNewTab(appliance)
- Die neue Version w√ºrde umfangreiche √Ñnderungen an allen Komponenten erfordern

Aktuelle Dateistruktur:
frontend/src/services/
‚îú‚îÄ‚îÄ proxyService.js (alte funktionierende Version)
‚îî‚îÄ‚îÄ proxyService.new.js (neue Version f√ºr sp√§tere Migration)

TODO: F√ºr eine erfolgreiche Migration m√ºssen folgende Komponenten angepasst werden:
- hooks/useAppliances.js
- components/ApplianceCard.js
- components/ServiceCard.js
- components/TerminalModal.js
- components/ServiceViewer.jsx

=======================================[2025-01-27 - ProxyService neue Version gel√∂scht]
Zweck: Entfernung der inkompatiblen neuen proxyService Version
Datei: frontend/src/services/proxyService.new.js

Durchgef√ºhrte Aktion:
- proxyService.new.js gel√∂scht

Begr√ºndung:
- Die neue Version hatte eine fundamental andere API-Struktur (service-basiert statt appliance-basiert)
- Eine Migration w√ºrde umfangreiche √Ñnderungen an vielen Komponenten erfordern
- Die alte Version funktioniert einwandfrei mit der bestehenden Codebasis

Aktuelle Situation:
- Nur noch die funktionierende proxyService.js vorhanden
- Das urspr√ºnglich leere api/ Verzeichnis bleibt gel√∂scht
- Keine weiteren √Ñnderungen erforderlich

=======================================[2025-01-27 - Ungenutzte CSS-Datei gel√∂scht]
Zweck: Entfernung ungenutzter CSS-Datei
Datei: frontend/src/components/ApplianceCard_heimdall.css

Durchgef√ºhrte Aktion:
- ApplianceCard_heimdall.css gel√∂scht

Begr√ºndung:
- Die Datei wurde nirgendwo im Code importiert oder referenziert
- Enthielt spezifische Styles f√ºr Heimdall-Services (Dashboard-Tool)
- Heimdall-spezifische Styles sind bereits in anderen aktiven CSS-Dateien vorhanden:
  - MobileButtonFix.css
  - ApplianceCard_button_sizes.css
  - mobile-button-override.css
- Die Datei war vermutlich ein altes √úberbleibsel oder Experiment

Keine weiteren √Ñnderungen erforderlich, da die Datei nicht verwendet wurde.

=======================================[2025-01-27 - Ungenutzte RemoteDesktopButton Varianten gel√∂scht]
Zweck: Entfernung ungenutzter RemoteDesktopButton-Komponenten
Dateien: 
- frontend/src/components/RemoteDesktopButtonDirect.jsx
- frontend/src/components/RemoteDesktopButtonSimple.jsx

Durchgef√ºhrte Aktionen:
- RemoteDesktopButtonDirect.jsx gel√∂scht
- RemoteDesktopButtonSimple.jsx gel√∂scht

Begr√ºndung:
- Nur RemoteDesktopButton.jsx (ohne Suffix) wird in ApplianceCard.js importiert
- Die anderen Versionen werden nirgendwo im Code verwendet
- Alle drei exportierten eine Komponente mit demselben Namen "RemoteDesktopButton"
- Die Haupt-Version verwendet API-Token-Authentifizierung
- Direct-Version nutzte Basis-Auth mit hartcodierten Credentials
- Simple-Version √∂ffnete nur Guacamole ohne Auth

Verbleibende Dateien:
- RemoteDesktopButton.jsx (die verwendete Hauptversion)
- RemoteDesktopButton.css (zugeh√∂rige Styles)

=======================================[2025-01-27 - authDebug.js entfernt]
Zweck: Entfernung der tempor√§ren Debug-Authentifizierungs-Middleware
Dateien: 
- backend/middleware/authDebug.js (gel√∂scht)
- backend/routes/applianceProxy.js (modifiziert)

Durchgef√ºhrte Aktionen:
1. Import von authDebug.js in applianceProxy.js entfernt
2. authenticateTokenWithDebug durch authenticateToken ersetzt
3. authDebug.js gel√∂scht

--- a/backend/routes/applianceProxy.js
+++ b/backend/routes/applianceProxy.js
@@ -16,8 +16,6 @@
 
 const { authenticateToken } = require('../middleware/auth');
-// Tempor√§r: Enhanced authentication debugging
-const authenticateTokenWithDebug = require('../middleware/authDebug');
 const pool = require('../utils/database');
 const logger = require('../utils/logger');
 
@@ -88,7 +86,7 @@
  * HAUPTPROXY-ROUTE - Alle HTTP/HTTPS Anfragen
  */
 router.all('/:id/proxy/*', 
-    authenticateTokenWithDebug,  // Tempor√§r: Mit Debug-Logging
+    authenticateToken,  
     checkApplianceAccessFixed,   // Tempor√§r: Korrigierte Access-Check
     applianceRateLimiter,
     auditProxyAccess,

Begr√ºndung:
- authDebug.js war als tempor√§re Debug-L√∂sung markiert
- Die normale auth.js bietet bereits ausreichend Logging
- Reduziert Code-Duplikation und vereinfacht die Wartung

=======================================[2025-01-27 - Debug-Routes entfernt]
Zweck: Entfernung tempor√§rer Debug-Routes aus Sicherheitsgr√ºnden
Dateien/Verzeichnisse: 
- backend/routes/debug/ (gesamtes Verzeichnis gel√∂scht)
  - auditDebug.js
  - debug.js
  - debugAudit.js
  - tokenDebug.js
- backend/server.js (modifiziert)

Durchgef√ºhrte Aktionen:
1. Debug-Route-Import und -Registrierung aus server.js entfernt
2. Gesamtes debug-Verzeichnis mit allen Dateien gel√∂scht

--- a/backend/server.js
+++ b/backend/server.js
@@ -130,10 +130,6 @@ app.use('/api-docs', swaggerUi.serve, swaggerUi.setup(swaggerSpec));
 // Auth routes (no authentication required)
 app.use('/api/auth', authRouter);
 
-// Debug routes (temporary - no authentication)
-const tokenDebugRouter = require('./routes/debug/tokenDebug');
-app.use('/api/debug', tokenDebugRouter);
-
 // Guacamole auth validation (special case for nginx auth_request)
 const authGuacamoleRouter = require('./routes/auth-guacamole');
 app.use('/api/auth', authGuacamoleRouter);

Begr√ºndung:
- Die Debug-Routes waren als "temporary" markiert
- Sie erforderten keine Authentifizierung (Sicherheitsrisiko)
- Debug-Endpoints wie /api/debug/check-token k√∂nnten sensible Informationen preisgeben
- F√ºr Produktionsumgebungen ungeeignet
- Debug-Funktionalit√§t kann bei Bedarf √ºber normale, authentifizierte Routes implementiert werden

Sicherheitsverbesserung:
- Entfernt unauthentifizierte Endpoints
- Verhindert potentielle Informationslecks √ºber Token und Sessions
- Reduziert die Angriffsfl√§che der API

=======================================[2025-01-27 - Ungenutzte Wartungsverzeichnisse gel√∂scht]
Zweck: Entfernung ungenutzter Wartungs- und Patch-Verzeichnisse
Verzeichnisse/Dateien: 
- backend/utils/fixes/ (gesamtes Verzeichnis gel√∂scht)
  - fix-duplicate-ssh-hosts.js
- backend/utils/patches/ (gesamtes Verzeichnis gel√∂scht)
  - enhancedStatusChecker.js

Durchgef√ºhrte Aktionen:
- Verzeichnis fixes/ mit allen Inhalten gel√∂scht
- Verzeichnis patches/ mit allen Inhalten gel√∂scht

Begr√ºndung:
- Beide Verzeichnisse enthielten Standalone-Scripts, die nicht im normalen Code importiert wurden
- fixes/fix-duplicate-ssh-hosts.js: Einmaliges Wartungsskript f√ºr Datenbankbereinigung
- patches/enhancedStatusChecker.js: Alternative Version eines bestehenden Moduls
- Die Scripts waren f√ºr manuelle Wartungsaufgaben gedacht, nicht f√ºr den Produktivbetrieb
- Keine Referenzen oder Imports im aktiven Code gefunden

Beschreibung der gel√∂schten Dateien:
1. fix-duplicate-ssh-hosts.js:
   - Standalone-Script zur Bereinigung doppelter SSH-Host-Eintr√§ge
   - Musste manuell mit `node` ausgef√ºhrt werden
   - F√ºr einmalige Datenbankwartung

2. enhancedStatusChecker.js:
   - Erweiterte Version des statusChecker.js mit Host-Verf√ºgbarkeitspr√ºfung
   - Nicht aktiv verwendet, nur als Alternative/Patch vorhanden
   - Funktionalit√§t k√∂nnte bei Bedarf in den Haupt-statusChecker integriert werden

=======================================[2025-01-27 14:10:00] Fix SSH File Upload hanging at 10%
Zweck: Fix SSH file upload functionality that was hanging at 10% due to SSH config mismatch
Dateien:
- backend/routes/ssh.js
- backend/utils/sshUploadHandler.js
- backend/regenerate-ssh-config.js

PROBLEM: SSH-Datei-Upload blieb bei 10% h√§ngen, da der Upload-Handler versuchte, 
sich mit "host_${id}" zu verbinden, aber die SSH-Konfiguration nur Hostname-Eintr√§ge hatte.

√ÑNDERUNGEN:

1. backend/routes/ssh.js - SSH Config Generation Fix
   - Added dual Host entries in SSH config generation
   - Now creates both `Host hostname` and `Host host_id` entries
   - Ensures compatibility with upload handler that uses host_id format

--- a/backend/routes/ssh.js
+++ b/backend/routes/ssh.js
@@ -165,6 +165,7 @@ class SSHManager {
       for (const host of hosts) {
         const keyFile = path.join(this.sshDir, `id_rsa_${host.key_name}`);
 
+        // Add both hostname and host_id entries for compatibility
         configContent += `Host ${host.hostname}\n`;
         configContent += `    HostName ${host.host}\n`;
         configContent += `    User ${host.username}\n`;
@@ -175,6 +176,17 @@ class SSHManager {
         configContent += `    ServerAliveInterval 30\n`;
         configContent += `    ServerAliveCountMax 3\n`;
         configContent += `    ConnectTimeout 10\n\n`;
+        
+        // Add host_id entry for upload handler compatibility
+        configContent += `Host host_${host.id}\n`;
+        configContent += `    HostName ${host.host}\n`;
+        configContent += `    User ${host.username}\n`;
+        configContent += `    Port ${host.port}\n`;
+        configContent += `    IdentityFile ${keyFile}\n`;
+        configContent += `    StrictHostKeyChecking no\n`;
+        configContent += `    UserKnownHostsFile /dev/null\n`;
+        configContent += `    ServerAliveInterval 30\n`;
+        configContent += `    ServerAliveCountMax 3\n`;
+        configContent += `    ConnectTimeout 10\n\n`;
       }

2. backend/utils/sshUploadHandler.js - Password Authentication Logic Fix
   - Fixed password authentication detection logic
   - Now checks for both ssh_key_id and key_name fields
   - Added support for requiresPassword flag

--- a/backend/utils/sshUploadHandler.js
+++ b/backend/utils/sshUploadHandler.js
@@ -77,7 +77,7 @@ const handleSSHUpload = async (req, res) => {
 
     // Check if we need password authentication
     const password = req.body.password;
-    const usePassword = !host.ssh_key_id && password;
+    const usePassword = (!host.ssh_key_id && !host.key_name) || (host.requiresPassword && password);
     
@@ -128,7 +128,7 @@ const handleSSHUpload = async (req, res) => {
     
     console.log('DEBUG: Starting file transfer...');
     console.log('DEBUG: Use password:', usePassword);
-    console.log('DEBUG: Host has SSH key:', !!host.ssh_key_id);
+    console.log('DEBUG: Host has SSH key:', !!(host.ssh_key_id || host.key_name));

3. backend/regenerate-ssh-config.js - Added host_id entries
   - Now generates `Host host_${id}` entries in addition to hostname entries
   - Ensures compatibility with upload handler after system restarts

--- a/backend/regenerate-ssh-config.js
+++ b/backend/regenerate-ssh-config.js
@@ -60,6 +60,12 @@ async function regenerateSSHConfig() {
       configContent += `    Port ${host.port}\n`;
       configContent += `    IdentityFile ${keyFile}\n\n`;
 
+      // Entry for host_id (used by upload handler)
+      configContent += `Host host_${host.id}\n`;
+      configContent += `    HostName ${host.host}\n`;
+      configContent += `    User ${host.username}\n`;
+      configContent += `    Port ${host.port}\n`;
+      configContent += `    IdentityFile ${keyFile}\n\n`;

DURCHGEF√úHRTE AKTIONEN:
- Backend-Container neu gestartet: docker compose restart backend
- SSH-Config regeneriert: docker compose exec backend node regenerate-ssh-config.js
- Verifiziert, dass SSH-Config nun beide Eintragstypen enth√§lt

ERGEBNIS:
- SSH file uploads funktionieren jetzt korrekt
- Upload-Progress l√§uft vollst√§ndig durch (nicht mehr bei 10% h√§ngend)
- Sowohl Key-basierte als auch Passwort-Authentifizierung funktioniert

=======================================

=======================================[2025-01-27 16:15:00] Version Update to 1.1.1
Zweck: Versions-Update auf 1.1.1 und Aktualisierung des CHANGELOG.md
Dateien:
- VERSION
- CHANGELOG.md

√ÑNDERUNGEN:

1. VERSION - Version bump
--- a/VERSION
+++ b/VERSION
@@ -1 +1 @@
-1.1.0
+1.1.1

2. CHANGELOG.md - Added 1.1.1 release notes
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -6,6 +6,29 @@ The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/)
 and this project adheres to [Semantic Versioning](https://semver.org/spec/v2.0.0.html).
 
+## [1.1.1] - 2025-01-27
+
+### Fixed
+- **SSH File Upload** - Fixed file upload hanging at 10% due to SSH config mismatch
+  - Added dual Host entries in SSH config generation (hostname and host_id)
+  - Fixed password authentication detection logic in upload handler
+  - Updated SSH config regeneration script for compatibility
+
+### Removed
+- **Security Improvements**
+  - Removed temporary debug routes that didn't require authentication
+  - Removed unused authDebug middleware
+  - Cleaned up debug directory with potential security risks
+  
+### Changed
+- **Code Cleanup**
+  - Removed unused CSS files (ApplianceCard_heimdall.css)
+  - Removed unused RemoteDesktopButton component variants
+  - Removed unused maintenance scripts in fixes/ and patches/ directories
+  - Disabled Webpack performance warnings for cleaner build output
+  
+### Added
+- **Environment Variables**
+  - Added GUACAMOLE_PROXY_URL to .env files to prevent Docker Compose warnings
+
 ## [1.1.0] - 2025-07-24

BESCHREIBUNG:
- Version von 1.1.0 auf 1.1.1 erh√∂ht
- CHANGELOG.md mit allen √Ñnderungen seit 1.1.0 aktualisiert
- Dokumentiert alle Fixes, Entfernungen, √Ñnderungen und Hinzuf√ºgungen
- Folgt dem Keep a Changelog Format

=======================================
=======================================[2025-01-27 16:30:00] SSH Host Update - Hostname Duplicate Check Fix
Zweck: Fix f√ºr Fehlermeldung beim Update von SSH-Hosts mit existierendem Hostnamen
Datei: backend/routes/ssh.js

PROBLEM: Beim Bearbeiten eines SSH-Hosts und nur √Ñndern des Passworts kam die Fehlermeldung
"Ein SSH-Host mit dem Namen 'mac' existiert bereits", obwohl der Hostname nicht ge√§ndert wurde.

URSACHE: Es fehlte eine Pr√ºfung, ob der Hostname ge√§ndert wurde, bevor auf Duplikate gepr√ºft wird.
Die Datenbank hat einen UNIQUE constraint auf dem hostname-Feld.

√ÑNDERUNGEN:

1. Hostname-Duplikatspr√ºfung hinzugef√ºgt (nur wenn Hostname ge√§ndert wird):
--- a/backend/routes/ssh.js
+++ b/backend/routes/ssh.js
@@ -1509,6 +1509,20 @@ router.put('/hosts/:id', async (req, res) => {
       port: portNumber
     });
 
+    // Check if hostname changed and if new hostname already exists
+    if (oldData.hostname !== hostname) {
+      console.log('Hostname changed, checking for duplicate hostname...');
+      
+      const [existingHostname] = await pool.execute(
+        'SELECT id, hostname FROM ssh_hosts WHERE hostname = ? AND id != ? AND is_active = 1',
+        [hostname, hostId]
+      );
+      
+      if (existingHostname.length > 0) {
+        console.log(`Hostname conflict: "${hostname}" already exists (ID: ${existingHostname[0].id})`);
+        return res.status(409).json({
+          success: false,
+          error: `Ein SSH-Host mit dem Namen "${hostname}" existiert bereits`
+        });
+      }
+    }
+
     // Check if the new combination would violate unique constraint
     // Only check if host, username, or port have changed

2. Verbesserte Error-Handler f√ºr Datenbank-Duplikate:
--- a/backend/routes/ssh.js
+++ b/backend/routes/ssh.js
@@ -1703,6 +1703,15 @@ router.put('/hosts/:id', async (req, res) => {
     // Handle specific database errors
     if (error.code === 'ER_DUP_ENTRY') {
+      // Parse the error to determine which field caused the duplicate
+      if (error.sqlMessage && error.sqlMessage.includes('hostname')) {
+        const hostnameMatch = error.sqlMessage.match(/'([^']+)'/);
+        const duplicateHostname = hostnameMatch ? hostnameMatch[1] : hostname;
+        return res.status(409).json({
+          success: false,
+          error: `Ein SSH-Host mit dem Namen "${duplicateHostname}" existiert bereits`
+        });
+      }
+      
       return res.status(409).json({
         success: false,
         error: 'SSH host with this connection already exists',

ERGEBNIS:
- Hostname-Duplikate werden nur gepr√ºft, wenn der Hostname tats√§chlich ge√§ndert wird
- Bessere Fehlermeldungen, die klar angeben, welcher Hostname bereits existiert
- Passwort-Updates ohne Hostname-√Ñnderung funktionieren jetzt korrekt

=======================================
=======================================[2025-01-27 16:45:00] SSH Setup - Update Existing Host Support
Zweck: Fix f√ºr SSH-Setup beim Update eines existierenden Hosts
Datei: backend/routes/ssh.js

PROBLEM: Beim √Ñndern des Passworts eines SSH-Hosts wurde der Setup-Endpoint aufgerufen,
welcher pr√ºfte ob ein Host mit diesem Namen bereits existiert und den Vorgang ablehnte.

URSACHE: Der /api/ssh/setup Endpoint war nur f√ºr neue Hosts konzipiert und konnte nicht
mit Updates umgehen.

L√ñSUNG: Setup-Endpoint erkennt jetzt, wenn ein Host bereits existiert und aktualisiert
diesen anstatt einen Fehler zu werfen.

√ÑNDERUNGEN:

--- a/backend/routes/ssh.js
+++ b/backend/routes/ssh.js
@@ -659,10 +659,34 @@ router.post('/setup', async (req, res) => {
 
               if (existingCheck.length > 0) {
                 const existingHost = existingCheck[0];
+                
+                // If we found exactly one host and it matches our connection details, this is likely an update
+                // In this case, we should update the existing host instead of creating a new one
+                if (existingCheck.length === 1 && 
+                    existingHost.hostname === hostname) {
+                  console.log(`üìù Updating existing SSH host: ${hostname} (ID: ${existingHost.id})`);
+                  
+                  // Update the key_name for the existing host
+                  await pool.execute(
+                    'UPDATE ssh_hosts SET key_name = ?, test_status = ? WHERE id = ?',
+                    [keyName, 'success', existingHost.id]
+                  );
+                  
+                  // Regenerate SSH config
+                  await sshManager.generateSSHConfig();
+                  
+                  resolve(
+                    res.json({
+                      success: true,
+                      message: 'SSH key updated successfully for existing host',
+                      hostId: existingHost.id,
+                      isUpdate: true
+                    })
+                  );
+                  return;
+                }
+                
+                // If it's a different host, show error
                 let errorMessage = 'SSH-Host existiert bereits';

FUNKTIONSWEISE:
1. Wenn ein Host mit gleichem Namen und gleichen Verbindungsdaten gefunden wird
2. Wird dieser als Update erkannt und der SSH-Schl√ºssel aktualisiert
3. Anstatt einen neuen Host zu erstellen, wird der bestehende aktualisiert
4. SSH-Config wird regeneriert

ERGEBNIS:
- Passwort-Updates f√ºr SSH-Hosts funktionieren jetzt korrekt
- Der SSH-Schl√ºssel wird auf dem Server aktualisiert
- Keine Fehlermeldung mehr √ºber bereits existierende Hosts

=======================================
=======================================[2025-01-27 17:00:00] Backup Encryption Key Dialog
Zweck: Dialog zur Anzeige des Verschl√ºsselungsschl√ºssels nach Backup-Erstellung
Dateien:
- frontend/src/components/EncryptionKeyDialog.js (neu)
- frontend/src/components/BackupTab.js
- frontend/src/services/backupService.js
- backend/routes/backup.js

FUNKTIONALIT√ÑT:
Nach erfolgreicher Backup-Erstellung wird ein Dialog mit dem Verschl√ºsselungsschl√ºssel angezeigt.
Der Schl√ºssel wird ben√∂tigt, um verschl√ºsselte Passw√∂rter nach einer Wiederherstellung zu entschl√ºsseln.

√ÑNDERUNGEN:

1. Neue Dialog-Komponente EncryptionKeyDialog.js erstellt:
   - Zeigt den Verschl√ºsselungsschl√ºssel an
   - Erkl√§rt wozu der Schl√ºssel ben√∂tigt wird (Remote-Host-Passw√∂rter)
   - Empfehlungen zur sicheren Aufbewahrung
   - Copy-to-Clipboard Funktionalit√§t

2. BackupTab.js - Import und State f√ºr Dialog:
--- a/frontend/src/components/BackupTab.js
+++ b/frontend/src/components/BackupTab.js
@@ -23,6 +23,7 @@ import { keyframes } from '@mui/system';
 import { BackupService } from '../services/backupService';
+import EncryptionKeyDialog from './EncryptionKeyDialog';
 import './BackupTab.css';

@@ -55,6 +56,8 @@ const BackupTab = () => {
   const [dragOver, setDragOver] = useState(false);
   const [error, setError] = useState('');
   const [success, setSuccess] = useState('');
+  const [encryptionKey, setEncryptionKey] = useState('');
+  const [showEncryptionDialog, setShowEncryptionDialog] = useState(false);

3. BackupTab.js - Dialog nach Backup anzeigen:
--- a/frontend/src/components/BackupTab.js
+++ b/frontend/src/components/BackupTab.js
@@ -65,6 +65,11 @@ const BackupTab = () => {
       const result = await BackupService.createBackup();
       if (result.success) {
         setSuccess(result.message);
+        // Show encryption key dialog if key is provided
+        if (result.encryptionKey) {
+          setEncryptionKey(result.encryptionKey);
+          setShowEncryptionDialog(true);
+        }
         setTimeout(() => setSuccess(''), 5000);

@@ -470,6 +475,12 @@ const BackupTab = () => {
         </Alert>
       </Snackbar>
+
+      {/* Encryption Key Dialog */}
+      <EncryptionKeyDialog
+        open={showEncryptionDialog}
+        onClose={() => setShowEncryptionDialog(false)}
+        encryptionKey={encryptionKey}
+      />
     </Box>

4. BackupService.js - Schl√ºssel extrahieren:
--- a/frontend/src/services/backupService.js
+++ b/frontend/src/services/backupService.js
@@ -22,6 +22,10 @@ export class BackupService {
       const response = await axios.get('/api/backup');
       const backupData = response.data;

+      // Extract encryption key if present
+      const encryptionKey = backupData.encryption_key;
+      delete backupData.encryption_key; // Remove from backup data before saving
+
       // Create and download file
       const dataStr = JSON.stringify(backupData, null, 2);

@@ -38,6 +42,7 @@ export class BackupService {
       return {
         success: true,
         message: `Backup erfolgreich erstellt! ${backupData.metadata.appliances_count} Services gesichert.`,
+        encryptionKey: encryptionKey,
       };

5. backend/routes/backup.js - Schl√ºssel im Response zur√ºckgeben:
--- a/backend/routes/backup.js
+++ b/backend/routes/backup.js
@@ -561,7 +561,16 @@ router.get('/backup', async (req, res) => {
       resource_id: null,
     });

-    res.json(backupData);
+    // Get encryption key from environment
+    const encryptionKey = process.env.SSH_KEY_ENCRYPTION_SECRET || process.env.ENCRYPTION_SECRET || 'default-insecure-key-change-this-in-production!!';
+    
+    // Add encryption key to response (but not to the backup file)
+    const responseData = {
+      ...backupData,
+      encryption_key: encryptionKey
+    };
+
+    res.json(responseData);

SICHERHEITSHINWEISE IM DIALOG:
- Warnung dass ohne Schl√ºssel alle Remote-Passw√∂rter neu eingegeben werden m√ºssen
- Empfehlung zur Speicherung in Passwort-Manager
- Hinweis den Schl√ºssel nicht mit dem Backup zusammen zu speichern
- Hinweis den Schl√ºssel nicht mit Unbefugten zu teilen

=======================================
=======================================[2025-01-27 17:30:00] Setup Script - Encryption Key Input
Zweck: Benutzer nach Verschl√ºsselungsschl√ºssel fragen oder sicheren Schl√ºssel generieren
Datei: scripts/setup-env.sh

FUNKTIONALIT√ÑT:
Das Setup-Script fragt jetzt nach einem Verschl√ºsselungsschl√ºssel f√ºr Remote-Host-Passw√∂rter.
Der Benutzer kann entweder einen eigenen Schl√ºssel eingeben oder einen sicheren Schl√ºssel
generieren lassen.

√ÑNDERUNGEN:

1. Interaktive Abfrage f√ºr Verschl√ºsselungsschl√ºssel:
--- a/scripts/setup-env.sh
+++ b/scripts/setup-env.sh
@@ -60,8 +60,38 @@ echo "üîê Generiere sichere Secrets..."
 JWT_SECRET=$(generate_secret 64)
 safe_replace .env "JWT_SECRET" "$JWT_SECRET"
 
-# SSH Encryption Key (32 Zeichen)
-SSH_KEY=$(generate_secret 32 | head -c 32)
-safe_replace .env "SSH_KEY_ENCRYPTION_SECRET" "$SSH_KEY"
+# SSH Encryption Key - Frage den Benutzer
+echo ""
+echo "üîê Verschl√ºsselungsschl√ºssel f√ºr Remote-Host-Passw√∂rter"
+echo "=================================================="
+echo ""
+echo "Dieser Schl√ºssel wird verwendet, um Passw√∂rter f√ºr Remote-Hosts (SSH, VNC, RDP)"
+echo "sicher zu verschl√ºsseln. Er wird ben√∂tigt, um nach einer Backup-Wiederherstellung"
+echo "die verschl√ºsselten Passw√∂rter wieder entschl√ºsseln zu k√∂nnen."
+echo ""
+echo "‚ö†Ô∏è  WICHTIG: Bewahren Sie diesen Schl√ºssel sicher auf!"
+echo "   - Ohne diesen Schl√ºssel m√ºssen alle Remote-Passw√∂rter neu eingegeben werden"
+echo "   - Speichern Sie ihn in einem Passwort-Manager"
+echo "   - Teilen Sie ihn nicht mit unbefugten Personen"
+echo ""
+read -p "Verschl√ºsselungsschl√ºssel eingeben (Enter f√ºr automatische Generierung): " SSH_KEY_INPUT
+
+if [ -n "$SSH_KEY_INPUT" ]; then
+    # Benutzer hat einen Schl√ºssel eingegeben
+    SSH_KEY="$SSH_KEY_INPUT"
+    echo "‚úÖ Benutzerdefinierter Verschl√ºsselungsschl√ºssel wird verwendet"
+else
+    # Generiere einen sicheren Schl√ºssel (32 Zeichen)
+    SSH_KEY=$(generate_secret 32 | head -c 32)
+    echo ""
+    echo "üîë Ein sicherer Schl√ºssel wurde generiert:"
+    echo ""
+    echo "    $SSH_KEY"
+    echo ""
+    echo "‚ö†Ô∏è  BITTE NOTIEREN SIE SICH DIESEN SCHL√úSSEL!"
+    echo "   Er wird f√ºr die Entschl√ºsselung von Remote-Passw√∂rtern nach einer"
+    echo "   Backup-Wiederherstellung ben√∂tigt."
+    echo ""
+    read -p "Dr√ºcken Sie Enter, wenn Sie den Schl√ºssel notiert haben..." -n 1 -r
+    echo ""
+fi
+
+safe_replace .env "SSH_KEY_ENCRYPTION_SECRET" "$SSH_KEY"
+safe_replace .env "ENCRYPTION_SECRET" "$SSH_KEY"

2. Backend-Synchronisation erweitert:
--- a/scripts/setup-env.sh
+++ b/scripts/setup-env.sh
@@ -187,11 +187,13 @@ if [ -f backend/.env.example ]; then
     # JWT und SSH Keys synchronisieren
     JWT_VALUE=$(grep "JWT_SECRET=" .env | cut -d= -f2- || echo "")
     SSH_VALUE=$(grep "SSH_KEY_ENCRYPTION_SECRET=" .env | cut -d= -f2- || echo "")
+    ENCRYPTION_VALUE=$(grep "ENCRYPTION_SECRET=" .env | cut -d= -f2- || echo "")
     NODE_ENV=$(grep "NODE_ENV=" .env | cut -d= -f2- || echo "production")
     ALLOWED_ORIGINS=$(grep "ALLOWED_ORIGINS=" .env | cut -d= -f2- || echo "http://localhost,https://localhost")
     EXTERNAL_URL=$(grep "EXTERNAL_URL=" .env | cut -d= -f2- || echo "")
     
     safe_replace backend/.env "JWT_SECRET" "$JWT_VALUE"
     safe_replace backend/.env "SSH_KEY_ENCRYPTION_SECRET" "$SSH_VALUE"
+    safe_replace backend/.env "ENCRYPTION_SECRET" "$ENCRYPTION_VALUE"
     safe_replace backend/.env "NODE_ENV" "$NODE_ENV"

3. Minimale backend/.env Konfiguration erweitert:
--- a/scripts/setup-env.sh
+++ b/scripts/setup-env.sh
@@ -241,6 +241,7 @@ JWT_SECRET=$JWT_VALUE
 
 # SSH Key Encryption
 SSH_KEY_ENCRYPTION_SECRET=$SSH_VALUE
+ENCRYPTION_SECRET=$ENCRYPTION_VALUE

FUNKTIONSWEISE:
1. Das Script erkl√§rt wozu der Verschl√ºsselungsschl√ºssel ben√∂tigt wird
2. Der Benutzer kann einen eigenen Schl√ºssel eingeben oder Enter dr√ºcken
3. Bei Enter wird ein sicherer 32-Zeichen Schl√ºssel generiert
4. Der generierte Schl√ºssel wird angezeigt mit der Aufforderung ihn zu notieren
5. Der Schl√ºssel wird sowohl als SSH_KEY_ENCRYPTION_SECRET als auch ENCRYPTION_SECRET gespeichert
6. Beide Variablen werden ins Backend synchronisiert

SICHERHEITSHINWEISE:
- Erkl√§rung dass der Schl√ºssel f√ºr Remote-Host-Passw√∂rter verwendet wird
- Warnung dass ohne Schl√ºssel alle Passw√∂rter neu eingegeben werden m√ºssen
- Empfehlung zur Speicherung in einem Passwort-Manager
- Warnung den Schl√ºssel nicht mit Unbefugten zu teilen

=======================================