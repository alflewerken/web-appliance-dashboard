#!/usr/bin/env node

/**
 * SSH Config Regeneration Script
 * Regenerates the SSH config file based on hosts in the database
 */

const mysql = require('mysql2/promise');
const fs = require('fs').promises;
const path = require('path');

// Database configuration from environment
const dbConfig = {
  host: process.env.DB_HOST || 'database',
  port: process.env.DB_PORT || 3306,
  user: process.env.DB_USER || 'dashboard_user',
  password: process.env.DB_PASSWORD || 'dashboard_pass123',
  database: process.env.DB_NAME || 'appliance_dashboard',
};

const SSH_CONFIG_PATH = '/root/.ssh/config';
const SSH_DIR = '/root/.ssh';

// Generate SSH config content
async function generateSSHConfig(connection) {
  const baseConfig = `# SSH Config auto-generated by Web Appliance Dashboard
# This file is automatically managed - manual changes may be overwritten

Host *
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
    LogLevel QUIET
    ConnectTimeout 10
    ServerAliveInterval 30
    ServerAliveCountMax 3
    PasswordAuthentication no
    PubkeyAuthentication yes
    IdentitiesOnly yes

# Default configuration for dashboard keys`;

  const configs = [baseConfig];

  try {
    // Get all active hosts with SSH keys
    const [hosts] = await connection.execute(`
      SELECT id, name, hostname, port, username, ssh_key_name
      FROM hosts 
      WHERE is_active = 1 
        AND ssh_key_name IS NOT NULL 
        AND ssh_key_name != ''
      ORDER BY name
    `);

    console.log(`Found ${hosts.length} hosts with SSH keys`);

    // Generate config for each host
    for (const host of hosts) {
      const hostConfig = `
# ${host.name}
Host ${host.hostname}
    HostName ${host.hostname}
    Port ${host.port || 22}
    User ${host.username}
    IdentityFile ${SSH_DIR}/id_rsa_${host.ssh_key_name}`;

      configs.push(hostConfig);
    }

    // Also add config for any orphaned SSH keys (keys without matching hosts)
    const files = await fs.readdir(SSH_DIR);
    const keyFiles = files.filter(f => f.startsWith('id_rsa_') && !f.endsWith('.pub'));
    
    for (const keyFile of keyFiles) {
      const keyName = keyFile.replace('id_rsa_', '');
      const hasHost = hosts.some(h => h.ssh_key_name === keyName);
      
      if (!hasHost) {
        console.log(`Found orphaned key: ${keyName}`);
        // Add generic config for orphaned keys
        const orphanConfig = `
# Orphaned key: ${keyName}
# This key exists but has no associated host`;
        configs.push(orphanConfig);
      }
    }

  } catch (error) {
    console.error('Error generating SSH config:', error);
  }

  return configs.join('\n');
}

// Main function
async function regenerateSSHConfig() {
  let connection;

  try {
    console.log('🔑 Regenerating SSH config...');
    console.log(`📁 SSH directory: ${SSH_DIR}`);
    console.log(`📄 Config file: ${SSH_CONFIG_PATH}`);

    // Ensure SSH directory exists
    try {
      await fs.access(SSH_DIR);
    } catch {
      console.log('Creating SSH directory...');
      await fs.mkdir(SSH_DIR, { recursive: true, mode: 0o700 });
    }

    // Connect to database
    connection = await mysql.createConnection(dbConfig);
    console.log('✅ Connected to database');

    // Generate new config
    const configContent = await generateSSHConfig(connection);

    // Write config file
    await fs.writeFile(SSH_CONFIG_PATH, configContent, { mode: 0o600 });
    console.log('✅ SSH config written successfully');
    
    // Fix ownership (important when running in Docker with shared volumes)
    try {
      const { exec } = require('child_process');
      const util = require('util');
      const execAsync = util.promisify(exec);
      await execAsync(`chown root:root ${SSH_CONFIG_PATH}`);
      console.log('✅ Fixed config file ownership');
    } catch (error) {
      console.warn('⚠️ Could not fix ownership (might not be running as root)');
    }

    // Verify the config was written
    const writtenContent = await fs.readFile(SSH_CONFIG_PATH, 'utf8');
    const lineCount = writtenContent.split('\n').length;
    console.log(`📊 Config file has ${lineCount} lines`);

  } catch (error) {
    console.error('❌ Error regenerating SSH config:', error);
    process.exit(1);
  } finally {
    if (connection) {
      await connection.end();
      console.log('🔌 Database connection closed');
    }
  }
}

// Run if executed directly
if (require.main === module) {
  regenerateSSHConfig()
    .then(() => {
      console.log('✅ SSH config regeneration completed');
      process.exit(0);
    })
    .catch(error => {
      console.error('Fatal error:', error);
      process.exit(1);
    });
}

// Export for use in other modules
module.exports = { regenerateSSHConfig };
