// Script to regenerate SSH config from database after restore

const pool = require('./utils/database');
const fs = require('fs').promises;
// Path module imported but not used - removed

async function regenerateSSHConfig() {
  let exitCode = 0;

  try {
    console.log('üîß Starting SSH config regeneration...');

    // Wait for database with timeout
    let dbReady = false;
    for (let i = 0; i < 10; i++) {
      try {
        await pool.execute('SELECT 1');
        dbReady = true;
        break;
      } catch (e) {
        console.log(`Waiting for database... (${i + 1}/10)`);
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    if (!dbReady) {
      throw new Error('Database not ready after 10 seconds');
    }

    const [hosts] = await pool.execute(`
      SELECT h.*, k.key_name as key_file
      FROM ssh_hosts h
      LEFT JOIN ssh_keys k ON h.key_name = k.key_name
      WHERE h.is_active = TRUE
      ORDER BY h.hostname
    `);

    console.log(`Found ${hosts.length} active SSH hosts`);

    let configContent =
      '# SSH Config auto-generated by Web Appliance Dashboard\n';
    configContent +=
      '# This file is automatically managed - manual changes may be overwritten\n\n';

    // Global defaults
    configContent += 'Host *\n';
    configContent += '    StrictHostKeyChecking no\n';
    configContent += '    UserKnownHostsFile /dev/null\n';
    configContent += '    LogLevel QUIET\n';
    configContent += '    ConnectTimeout 10\n';
    configContent += '    ServerAliveInterval 30\n';
    configContent += '    ServerAliveCountMax 3\n';
    configContent += '    PasswordAuthentication no\n';
    configContent += '    PubkeyAuthentication yes\n';
    configContent += '    IdentitiesOnly yes\n\n';

    for (const host of hosts) {
      const keyFile = `/root/.ssh/id_rsa_${host.key_name}`;

      // Entry for hostname
      configContent += `Host ${host.hostname}\n`;
      configContent += `    HostName ${host.host}\n`;
      configContent += `    User ${host.username}\n`;
      configContent += `    Port ${host.port}\n`;
      configContent += `    IdentityFile ${keyFile}\n\n`;

      // Entry for host_id (used by upload handler)
      configContent += `Host host_${host.id}\n`;
      configContent += `    HostName ${host.host}\n`;
      configContent += `    User ${host.username}\n`;
      configContent += `    Port ${host.port}\n`;
      configContent += `    IdentityFile ${keyFile}\n\n`;

      // Also create entry for IP/hostname if different
      if (host.hostname !== host.host) {
        configContent += `Host ${host.host}\n`;
        configContent += `    HostName ${host.host}\n`;
        configContent += `    User ${host.username}\n`;
        configContent += `    Port ${host.port}\n`;
        configContent += `    IdentityFile ${keyFile}\n\n`;
      }
    }

    // Ensure SSH directory exists
    const sshDir = '/root/.ssh';
    await fs.mkdir(sshDir, { recursive: true, mode: 0o700 });

    // Write config file
    await fs.writeFile('/root/.ssh/config', configContent, { mode: 0o600 });
    console.log('‚úÖ SSH config regenerated successfully');
  } catch (error) {
    console.error('‚ùå Error regenerating SSH config:', error.message);
    exitCode = 1;
  } finally {
    // Always close database connection
    try {
      await pool.end();
    } catch (closeError) {
      console.error('Error closing database:', closeError.message);
    }
    process.exit(exitCode);
  }
}

// Run the regeneration
regenerateSSHConfig();
