// SSH Manager - Centralized SSH configuration management
const fs = require('fs').promises;
const path = require('path');
const pool = require('./database');
const { spawn } = require('child_process');

class SSHManager {
  constructor(config) {
    this.config = config;
    this.sshDir = '/root/.ssh';
  }

  // Generate SSH config from database
  async regenerateSSHConfig() {
    try {
      const [hosts] = await pool.execute(`
        SELECT h.*, k.key_name as key_file
        FROM ssh_hosts h
        LEFT JOIN ssh_keys k ON h.key_name = k.key_name
        WHERE h.is_active = TRUE
        ORDER BY h.hostname
      `);

      let configContent =
        '# SSH Config auto-generated by Web Appliance Dashboard\n';
      configContent +=
        '# This file is automatically managed - manual changes may be overwritten\n';
      configContent += '# Generated at: ' + new Date().toISOString() + '\n\n';

      // Global defaults
      configContent += 'Host *\n';
      configContent += '    StrictHostKeyChecking no\n';
      configContent += '    UserKnownHostsFile /dev/null\n';
      configContent += '    LogLevel QUIET\n';
      configContent += '    ConnectTimeout 10\n';
      configContent += '    ServerAliveInterval 30\n';
      configContent += '    ServerAliveCountMax 3\n';
      configContent += '    PasswordAuthentication no\n';
      configContent += '    PubkeyAuthentication yes\n';
      configContent += '    IdentitiesOnly yes\n\n';

      // Track unique hosts to avoid duplicates
      const processedHosts = new Set();

      for (const host of hosts) {
        const keyFile = `/root/.ssh/id_rsa_${host.key_name}`;

        // Verify key exists
        try {
          await fs.access(keyFile);
        } catch (error) {
          continue; // Skip this host if key doesn't exist
        }

        // Entry for hostname (if not already processed)
        if (!processedHosts.has(host.hostname)) {
          configContent += `# ${host.hostname} configuration\n`;
          configContent += `Host ${host.hostname}\n`;
          configContent += `    HostName ${host.host}\n`;
          configContent += `    User ${host.username}\n`;
          configContent += `    Port ${host.port}\n`;
          configContent += `    IdentityFile ${keyFile}\n\n`;
          processedHosts.add(host.hostname);
        }

        // Also create entry for IP/hostname if different and not already processed
        if (host.hostname !== host.host && !processedHosts.has(host.host)) {
          configContent += `# Direct IP/hostname access for ${host.hostname}\n`;
          configContent += `Host ${host.host}\n`;
          configContent += `    HostName ${host.host}\n`;
          configContent += `    User ${host.username}\n`;
          configContent += `    Port ${host.port}\n`;
          configContent += `    IdentityFile ${keyFile}\n\n`;
          processedHosts.add(host.host);
        }
      }

      // Write config file
      const configPath = path.join(this.sshDir, 'config');
      await fs.writeFile(configPath, configContent, { mode: 0o600 });

      return configPath;
    } catch (error) {
      throw error;
    }
  }

  // Verify SSH key pair
  async verifyKeyPair(keyName) {
    const privateKeyPath = path.join(this.sshDir, `id_rsa_${keyName}`);
    const publicKeyPath = `${privateKeyPath}.pub`;

    try {
      // Check if files exist
      await fs.access(privateKeyPath);
      await fs.access(publicKeyPath);

      // Verify key format
      const privateKey = await fs.readFile(privateKeyPath, 'utf8');
      const publicKey = await fs.readFile(publicKeyPath, 'utf8');

      const isValidPrivate =
        privateKey.includes('-----BEGIN') && privateKey.includes('-----END');
      const isValidPublic =
        publicKey.startsWith('ssh-rsa') || publicKey.startsWith('ssh-ed25519');

      return {
        valid: isValidPrivate && isValidPublic,
        privateKeyPath,
        publicKeyPath,
        privateKeyValid: isValidPrivate,
        publicKeyValid: isValidPublic,
      };
    } catch (error) {
      return {
        valid: false,
        error: error.message,
      };
    }
  }

  // Sync keys from database to filesystem
  async syncKeysToFilesystem() {
    try {
      const [keys] = await pool.execute(
        'SELECT * FROM ssh_keys WHERE private_key IS NOT NULL'
      );
      let syncedCount = 0;

      for (const key of keys) {
        const privateKeyPath = path.join(this.sshDir, `id_rsa_${key.key_name}`);
        const publicKeyPath = `${privateKeyPath}.pub`;

        try {
          // Write private key
          await fs.writeFile(privateKeyPath, key.private_key, { mode: 0o600 });

          // Write public key if available
          if (key.public_key) {
            await fs.writeFile(publicKeyPath, key.public_key, { mode: 0o644 });
          }

          syncedCount++;
        } catch (error) {}
      }

      return syncedCount;
    } catch (error) {
      throw error;
    }
  }

  // Test SSH connection
  async testConnection(host) {
    return new Promise(resolve => {
      const keyPath = path.join(this.sshDir, `id_rsa_${host.key_name}`);

      const sshCmd = spawn('ssh', [
        '-i',
        keyPath,
        '-o',
        'StrictHostKeyChecking=no',
        '-o',
        'UserKnownHostsFile=/dev/null',
        '-o',
        'ConnectTimeout=5',
        '-o',
        'BatchMode=yes',
        '-p',
        host.port.toString(),
        `${host.username}@${host.host}`,
        'echo "SSH_TEST_OK"',
      ]);

      let stdout = '';
      let stderr = '';

      sshCmd.stdout.on('data', data => {
        stdout += data.toString();
      });

      sshCmd.stderr.on('data', data => {
        stderr += data.toString();
      });

      sshCmd.on('close', code => {
        const success = code === 0 && stdout.includes('SSH_TEST_OK');
        resolve({
          success,
          output: stdout,
          error: stderr,
          exitCode: code,
        });
      });

      sshCmd.on('error', error => {
        resolve({
          success: false,
          error: error.message,
        });
      });
    });
  }
}

// Export functions for backward compatibility
const regenerateSSHConfig = async () => {
  const manager = new SSHManager({});
  return manager.regenerateSSHConfig();
};

module.exports = {
  SSHManager,
  regenerateSSHConfig,
};
